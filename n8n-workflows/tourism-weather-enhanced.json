{
  "name": "æ™ºæ…§æ—…æ¸¸ - å¤©æ°”æŸ¥è¯¢(å¢å¼ºç‰ˆ)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "tourism/weather",
        "responseMode": "responseNode",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Access-Control-Allow-Origin", "value": "*" }
            ]
          }
        }
      },
      "id": "webhook-weather",
      "name": "Webhook å¤©æ°”æŸ¥è¯¢",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [200, 300]
    },
    {
      "parameters": {
        "jsCode": "// è·å–è¯·æ±‚å‚æ•°\nconst body = $input.first().json.body || $input.first().json;\nconst spots = body.spots || ['è¥¿æŸå¡çºªå¿µé¦†'];\nconst date = body.date || new Date().toISOString().split('T')[0];\n\n// æ™¯ç‚¹å¯¹åº”çš„åŸå¸‚å’Œåæ ‡\nconst spotCityMap = {\n  'è¥¿æŸå¡çºªå¿µé¦†': { city: 'çŸ³å®¶åº„', lat: 38.31, lng: 114.18 },\n  'ç‹¼ç‰™å±±äº”å£®å£«çºªå¿µåœ°': { city: 'ä¿å®š', lat: 39.22, lng: 115.32 },\n  'ç™½æ´‹æ·€é›ç¿é˜Ÿçºªå¿µé¦†': { city: 'ä¿å®š', lat: 38.92, lng: 115.98 },\n  'å¡ç½•åå±•è§ˆé¦†': { city: 'æ‰¿å¾·', lat: 42.40, lng: 117.32 },\n  'ä¸€äºŒä¹å¸ˆå¸ä»¤éƒ¨æ—§å€': { city: 'é‚¯éƒ¸', lat: 36.78, lng: 113.92 },\n  'å†‰åº„åœ°é“æˆ˜é—å€': { city: 'ä¿å®š', lat: 38.68, lng: 115.52 },\n  'è‘£å­˜ç‘çƒˆå£«é™µå›­': { city: 'æ‰¿å¾·', lat: 41.32, lng: 117.73 },\n  'æå¤§é’Šçºªå¿µé¦†': { city: 'å”å±±', lat: 39.63, lng: 118.18 }\n};\n\n// å­£èŠ‚æ€§å¤©æ°”æ¨¡æ¿ï¼ˆç”¨äºé™çº§ï¼‰\nconst seasonWeather = {\n  spring: { conditions: ['æ™´', 'å¤šäº‘', 'å°é›¨'], tempRange: [8, 22], humidity: [40, 60] },\n  summer: { conditions: ['æ™´', 'å¤šäº‘', 'é›·é˜µé›¨', 'é˜´'], tempRange: [22, 35], humidity: [50, 80] },\n  autumn: { conditions: ['æ™´', 'å¤šäº‘', 'é˜´'], tempRange: [10, 25], humidity: [35, 55] },\n  winter: { conditions: ['æ™´', 'å¤šäº‘', 'å°é›ª', 'é˜´'], tempRange: [-8, 8], humidity: [30, 50] }\n};\n\n// è·å–å½“å‰å­£èŠ‚\nfunction getSeason(dateStr) {\n  const month = new Date(dateStr).getMonth() + 1;\n  if (month >= 3 && month <= 5) return 'spring';\n  if (month >= 6 && month <= 8) return 'summer';\n  if (month >= 9 && month <= 11) return 'autumn';\n  return 'winter';\n}\n\n// ç”Ÿæˆæ¨¡æ‹Ÿå¤©æ°”æ•°æ®\nfunction generateMockWeather(spotName, dateStr) {\n  const season = getSeason(dateStr);\n  const sw = seasonWeather[season];\n  const condition = sw.conditions[Math.floor(Math.random() * sw.conditions.length)];\n  const minTemp = sw.tempRange[0] + Math.floor(Math.random() * 5);\n  const maxTemp = sw.tempRange[1] - Math.floor(Math.random() * 5);\n  const humidity = sw.humidity[0] + Math.floor(Math.random() * (sw.humidity[1] - sw.humidity[0]));\n  \n  // æ ¹æ®å¤©æ°”ç”Ÿæˆå»ºè®®\n  let suggestion = 'å¤©æ°”é€‚å®œå‡ºè¡Œï¼Œç¥æ—…é€”æ„‰å¿«ï¼';\n  if (condition.includes('é›¨')) suggestion = 'â˜” å»ºè®®æºå¸¦é›¨å…·ï¼Œæ³¨æ„é˜²æ»‘';\n  else if (condition.includes('é›ª')) suggestion = 'â„ï¸ é“è·¯å¯èƒ½æ¹¿æ»‘ï¼Œæ³¨æ„ä¿æš–å’Œå®‰å…¨';\n  else if (maxTemp > 30) suggestion = 'ğŸŒ¡ï¸ å¤©æ°”ç‚çƒ­ï¼Œæ³¨æ„é˜²æš‘é™æ¸©ï¼Œå¤šè¡¥å……æ°´åˆ†';\n  else if (minTemp < 0) suggestion = 'ğŸ§¥ å¤©æ°”å¯’å†·ï¼Œæ³¨æ„ä¿æš–ï¼Œç©¿åšå¤–å¥—';\n  else if (condition === 'æ™´') suggestion = 'â˜€ï¸ å¤©æ°”æ™´å¥½ï¼Œé€‚åˆæˆ·å¤–æ´»åŠ¨ï¼Œæ³¨æ„é˜²æ™’';\n  \n  return {\n    spotName,\n    city: spotCityMap[spotName]?.city || 'çŸ³å®¶åº„',\n    date: dateStr,\n    condition,\n    icon: getWeatherIcon(condition),\n    temperature: { min: minTemp, max: maxTemp, current: Math.round((minTemp + maxTemp) / 2) },\n    humidity,\n    windSpeed: Math.floor(Math.random() * 20) + 5,\n    windDirection: ['ä¸œé£', 'å—é£', 'è¥¿é£', 'åŒ—é£'][Math.floor(Math.random() * 4)],\n    aqi: Math.floor(Math.random() * 100) + 30,\n    uvIndex: Math.floor(Math.random() * 8) + 1,\n    suggestion,\n    forecast: generateForecast(dateStr, season)\n  };\n}\n\n// è·å–å¤©æ°”å›¾æ ‡\nfunction getWeatherIcon(condition) {\n  const icons = {\n    'æ™´': 'â˜€ï¸', 'å¤šäº‘': 'â›…', 'é˜´': 'â˜ï¸',\n    'å°é›¨': 'ğŸŒ§ï¸', 'ä¸­é›¨': 'ğŸŒ§ï¸', 'å¤§é›¨': 'â›ˆï¸', 'é›·é˜µé›¨': 'â›ˆï¸',\n    'å°é›ª': 'ğŸŒ¨ï¸', 'ä¸­é›ª': 'â„ï¸', 'å¤§é›ª': 'â„ï¸'\n  };\n  return icons[condition] || 'ğŸŒ¤ï¸';\n}\n\n// ç”Ÿæˆæœªæ¥3å¤©é¢„æŠ¥\nfunction generateForecast(startDate, season) {\n  const sw = seasonWeather[season];\n  const forecast = [];\n  for (let i = 1; i <= 3; i++) {\n    const date = new Date(startDate);\n    date.setDate(date.getDate() + i);\n    const condition = sw.conditions[Math.floor(Math.random() * sw.conditions.length)];\n    forecast.push({\n      date: date.toISOString().split('T')[0],\n      condition,\n      icon: getWeatherIcon(condition),\n      tempMin: sw.tempRange[0] + Math.floor(Math.random() * 5),\n      tempMax: sw.tempRange[1] - Math.floor(Math.random() * 5)\n    });\n  }\n  return forecast;\n}\n\n// ä¸ºæ¯ä¸ªæ™¯ç‚¹ç”Ÿæˆå¤©æ°”æ•°æ®\nconst weatherData = spots.map(spot => generateMockWeather(spot, date));\n\nreturn {\n  success: true,\n  queryDate: date,\n  weather: weatherData,\n  dataSource: 'mock',\n  tips: [\n    'å¤©æ°”æ•°æ®ä»…ä¾›å‚è€ƒï¼Œå‡ºè¡Œå‰è¯·å…³æ³¨æœ€æ–°å¤©æ°”é¢„æŠ¥',\n    'å±±åŒºå¤©æ°”å¤šå˜ï¼Œå»ºè®®æºå¸¦é›¨å…·',\n    'æ—©æ™šæ¸©å·®è¾ƒå¤§ï¼Œæ³¨æ„å¢å‡è¡£ç‰©'\n  ]\n};"
      },
      "id": "generate-weather",
      "name": "ç”Ÿæˆå¤©æ°”æ•°æ®",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [500, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "respond-weather",
      "name": "è¿”å›å¤©æ°”å“åº”",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [800, 300]
    }
  ],
  "connections": {
    "Webhook å¤©æ°”æŸ¥è¯¢": {
      "main": [[{ "node": "ç”Ÿæˆå¤©æ°”æ•°æ®", "type": "main", "index": 0 }]]
    },
    "ç”Ÿæˆå¤©æ°”æ•°æ®": {
      "main": [[{ "node": "è¿”å›å¤©æ°”å“åº”", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
